import numpy as np

from app.analysers import SquareMatrixAnalyser, EchelonMatrixAnalyser
from app.system import LinearSystem
from app.transformers import LinearSystemGaussTransformer


def get_inverse_matrix(A: np.ndarray):
    """
    Находит обратную матрицу для квадратной матрицы

    A^-1 - ?

    AX = E => X = A^-1 (X - матрица, а не столбец, как в обычной линейной системе)

    Систему AX = E представим как матрицу (A|E)
    и приведем элементарными преобразованиями к ступенчатому виду.

    Если в результате получится (E|B), т.е. EX = B => X = B,
    значит матрица A обратима и A^-1 = B.

    Если в результате получится (C|B), где C != E, то матрица A необратима,
    потому что С - улучшенный ступенчатый вид A, и в нем есть хотя бы одна свободная переменная,
    а это значит, что у системы Ax = 0 (где x - столбец) существует решение x != 0,
    что говорит о том, что система необратима.
    """
    # Проверяем, что матрица квадратная (2D и размерности равны)
    assert A.ndim == 2 and A.shape[0] == A.shape[1]

    # Создаем единичную матрицу того же размера, что и исходная
    # Обратная матрица A^(-1) определяется как A * A^(-1) = E,
    # где E - единичная матрица
    E = np.eye(A.shape[0], A.shape[0])

    # Создаем линейную систему: A * X = E, где X - искомая обратная матрица
    # system.A = исходная матрица, system.B = единичная матрица
    system = LinearSystem(A, E)

    # Применяем метод Гаусса для приведения матрицы A к единичной
    # Одновременно преобразуем правую часть (единичную матрицу)
    transformer = LinearSystemGaussTransformer(system)
    transformer.apply_gauss()  # После этой операции A должна стать единичной матрицей

    # Проверяем, что исходная матрица была невырожденной (обратимой)
    # Если после метода Гаусса A стала единичной матрицей - матрица обратима
    analyser = SquareMatrixAnalyser(system.A)
    if not analyser.is_identity():
        # Матрица вырожденная (определитель = 0), обратной не существует
        raise ValueError('Input matrix is singular.')

    # После преобразований system.B содержит обратную матрицу,
    # так как мы решили уравнение A * X = I и получили X = A^(-1)
    return system.B


def get_left_inverse_matrix(A: np.ndarray):
    """
    Находит левую обратную матрицу для матрицы A размера m×n, где m > n.
    Левая обратная L удовлетворяет условию: L·A = E_n
    (где E_n - единичная матрица размера n×n)

    Алгоритм:
    1. Создаем расширенную матрицу [A | E_m]
    2. Приводим левую часть (A) к ступенчатому виду методом Гаусса
    3. Если ранг A = n, то первые n строк правой части - искомая левая обратная

    Параметры:
    A: np.ndarray - исходная матрица размерности m×n, m >= n

    Возвращает:
    np.ndarray - левая обратная матрица размерности n×m

    Исключения:
    - Если m < n (невозможно найти левую обратную)
    - Если rank(A) < n (матрица не полного ранга по столбцам)
    """
    # Проверяем, что входной массив - двумерная матрица
    assert A.ndim == 2

    # Получаем размеры матрицы: m - строки, n - столбцы
    m, n = A.shape

    # Левая обратная существует только когда строк >= столбцов
    assert m >= n, "Для левой обратной требуется m >= n (больше строк, чем столбцов)"

    # Создаем единичную матрицу размера m×m (правая часть расширенной матрицы)
    Em = np.eye(m, m)

    # Создаем линейную систему с расширенной матрицей [A | E_m]
    # Идея: ищем такую матрицу E, что E·A = R (приведенная форма)
    # После преобразований первые n строк E будут левой обратной
    system = LinearSystem(A, Em)

    # Применяем метод Гаусса для приведения матрицы A к ступенчатому виду
    # При этом те же элементарные преобразования применяются и к правой части Em
    transformer = LinearSystemGaussTransformer(system)
    transformer.apply_gauss()

    # Проверяем ранг приведенной матрицы
    # Ранг должен быть равен n (полный ранг по столбцам)
    analyser = EchelonMatrixAnalyser(system.A)
    if analyser.get_rank() != n:
        raise ValueError(
            f"Невозможно найти левую обратную: ранг матрицы ({analyser.get_rank()}) "
            f"меньше числа столбцов ({n}). Матрица не имеет полного ранга по столбцам."
        )

    # После преобразований Гаусса:
    # - system.A содержит приведенную форму исходной матрицы A
    # - system.B содержит преобразованную правую часть (изначально E_m)
    #
    # Из теории: если E - матрица элементарных операций такая, что E·A = R,
    # где R - приведенная форма, то первые n строк E дают левую обратную L,
    # при условии, что ранг A = n и R = [E_n; 0] (первые n строк - единичная матрица)
    return system.B[:n]  # Берем первые n строк преобразованной правой части


def get_right_inverse_matrix(A: np.ndarray):
    assert A.ndim == 2

    # Получаем размеры матрицы A
    # m - количество строк (rows), n - количество столбцов (columns)
    m, n = A.shape

    # Правая обратная существует только для матриц, у которых
    # число строк меньше или равно числу столбцов (m <= n)
    # Это связано с тем, что для существования правой обратной
    # система A·R = E_m должна иметь хотя бы одно решение.
    # При m > n система переопределена и может не иметь решений
    if m > n:
        raise ValueError("Для правой обратной требуется m <= n")

    # -----------------------------------------------------------
    # КЛЮЧЕВАЯ МАТЕМАТИЧЕСКАЯ ИДЕЯ:
    # -----------------------------------------------------------
    # Ищем R такую, что: A·R = E_m (уравнение 1)
    # 
    # Возьмем транспонирование от обеих частей:
    # (A·R)^T = E_m^T
    # R^T·A^T = E_m (так как (AB)^T = B^T·A^T и E_m^T = E_m)
    #
    # Обозначим L = R^T. Тогда:
    # L·A^T = E_m (уравнение 2)
    #
    # Уравнение 2 означает, что L - это ЛЕВАЯ обратная для A^T!
    # Поэтому алгоритм:
    # 1. Находим L как левую обратную для A^T
    # 2. Восстанавливаем R = L^T
    # -----------------------------------------------------------

    # Шаг 1: Транспонируем исходную матрицу
    # A_T будет иметь размер n×m (поменялись местами строки и столбцы)
    A_T = A.T

    # Шаг 2: Находим левую обратную для транспонированной матрицы
    # Функция get_left_inverse_matrix(A_T) возвращает матрицу L размерности m×n,
    # которая удовлетворяет условию: L·A_T = E_m
    #
    # Важно: Для успешного выполнения этой функции должны выполняться условия:
    # 1. Для матрицы A_T (размер n×m): n >= m (выполняется, так как m <= n по условию)
    # 2. rank(A_T) = m (эквивалентно rank(A) = m, так как rank(A) = rank(A^T))
    #
    # Если эти условия не выполняются, get_left_inverse_matrix выбросит исключение
    L_A_T = get_left_inverse_matrix(A_T)

    # Шаг 3: Транспонируем результат обратно
    # L_A_T имеет размер m×n, её транспонирование R = L_A_T^T даст матрицу n×m
    # Это и есть искомая правая обратная к исходной матрице A
    R = L_A_T.T

    # -----------------------------------------------------------
    # ПРОВЕРКА КОРРЕКТНОСТИ (для понимания):
    # -----------------------------------------------------------
    # После выполнения алгоритма:
    # 1. L_A_T·A_T = E_m (по определению левой обратной)
    # 2. (L_A_T·A_T)^T = E_m^T
    # 3. A·L_A_T^T = E_m
    # 4. A·R = E_m ✓
    # -----------------------------------------------------------
    return R
