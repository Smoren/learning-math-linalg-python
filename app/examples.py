import numpy as np

"""
Замечание про обратные матрицы:
(AB)⁻¹ = B⁻¹ * A⁻¹

Доказательство: Попробуем предъявить обратную матрицу к матрице AB.

(A * B) * (B⁻¹ * A⁻¹) = A * (B * B⁻¹) * A⁻¹ = A * E * A⁻¹ = A * A⁻¹ = E.
Значит, обратная матрица к AB - это B⁻¹ * A⁻¹.

С другой стороны тоже работает:
(B⁻¹ * A⁻¹) * (A * B) = B⁻¹ * (A⁻¹ * A) * B = B⁻¹ * E * B = B⁻¹ * B = E.

======================

ТЕОРЕМА
Если A - квадратная матрица, то следующие утверждения эквивалентны друг другу:
1. A * x = 0 имеет единственное решение: x = 0 (x ∈ R^n)
2. A^T * y = 0 имеет единственное решение: y = 0 (y ∈ R^n)
3. A = U1 * U2 * ... * Uk, где U1, U2, ..., Uk, где Ui - элементарные матрицы (соответствующие элементарным преобразованиям: add, mul, swap)
4. Существует обратная матрица A⁻¹
5. Матрица A обратима слева (∃ L: LA = E)
6. Матрица A обратима справа (∃ R: AR = E)
"""

"""
Если A, B ∈ Mmn(R) (являются матрицами m×n),
E_A = {x | Ax = 0}, E_B = {x | Ay = 0} (множества решений),
то следующие утверждения эквивалентны друг другу:
1. E_A = E_B
2. A можно привести к B с помощью элементарных преобразований
3. Существует C: A = C * B, где C ∈ Mmm(R) и C является обратимой матрицей (C = U1 * U2 * ... * Uk, где Ui - элементарные матрицы)
4. Улучшенный ступенчатый вид матриц A и B совпадает (для любой матрицы ступенчатый вид единственный)
"""

"""
# Многочлены

Обозначение:
R[x] - многочлен действительных чисел относительно переменной x

Общий вид:
P = a₀ + a₁x + a₂x² + ... + aₘxᵐ

Для квадратной матрицы X ∈ Mₙ(R):
P = a₀E + a₁X + a₂X² + ... + aₘXᵐ (в результате также получим матрицу Y ∈ Mₙ(R))

## Утверждения для матрицы A ∈ Mₙ(R) и многочленов f,g ∈ R[x]:
1. (f+g)(A) = f(A) + g(A)
2. (f*g)(A) = f(A) * g(A)
3. f(λE) = f(λ) * E (λE - скалярная матрица)
4. Для C ∈ Mₙ(R) ∃ C⁻¹: f(C⁻¹AC) = C⁻¹f(A)C (операция сопряжения)

## Сложение и умножение

### Сложение:
S = ∑{k=0, n} (a_k + b_k)*x^k

### Умножение:
P = a₀ + a₁x + ... + aₘxᵐ (степень m)
Q = b₀ + b₁x + ... + bₙxⁿ (степень n)

P*Q = ∑_{k=0}^{m+n} (∑_{i+j=k} a_i*b_j) * x^k, где i = 0...m, j = 0...n

Объяснение:
Их произведение T(x) = P(x) * Q(x) будет многочленом степени m + n. 
Коэффициент c_k при степени x^k в произведении вычисляется по формуле:
c_k = ∑{i+j=k} a_i*b_j, где i = 0...m, j = 0...n

Или в развёрнутом виде для многочлена T(x):
T(x) = c₀ + c₁x + c₂x² + ... + c_{m+n}x^{m+n}, где
c₀ = a₀b₀                   (i+j = 0+0              = 0 = k)
c₁ = a₀b₁ + a₁b₀            (i+j = 0+1 = 1+0        = 1 = k)
c₂ = a₀b₂ + a₁b₁ + a₂b₀     (i+j = 0+2 = 1+1 = 2+0  = 2 = k)
...
c_k = a₀b_k + a₁b_{k-1} + ... + a_{k-1}b₁ + a_kb₀ (при условии, что a_i = 0 при i > m и b_j = 0 при j > n)
...
c_{m+n} = aₘ * bₙ
"""

def example_transform_matrix_add_row():
    A = np.array([
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 1, 0],  # i = 1, j = 3
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1],
    ])

    print(A)
    print(T @ A)  # к строке с индексом i=1 прибавляем строку с индексом j=3
    print(A @ T)  # к столбцу с индексом j=3 прибавляем столбец с индексом i=1

    Ti = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, -1, 0],  # i = 1, j = 3
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1],
    ])

    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_transform_matrix_mul_row():
    A = np.array([
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 2, 0],  # i = 3, множитель = 2
        [0, 0, 0, 0, 1],
    ])

    print(A)
    print(T @ A)  # умножаем строку с индексом 3 на 2
    print(A @ T)  # умножаем строку с индексом 3 на 2

    Ti = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1 / 2, 0],  # i = 3, множитель = 1/2
        [0, 0, 0, 0, 1],
    ])
    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_transform_matrix_swap_rows():
    A = np.array([
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1],  # i = 1, j = 4
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0],  # i = 4, j = 1
    ])

    print(A)
    print(T @ A)  # меняем местами строки с индексами 1 и 4
    print(A @ T)  # меняем местами столбцы с индексами 1 и 4

    Ti = T
    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_multiply_per_block():
    """
    Блочные формулы

    Мы как бы заполняем матрицу не числами, а другими матрицами.

        k   l         u   v           u       v
      +---+---+     +---+---+     +-------+-------+
    m | A | B |   k | X | Y |   m | AX+BZ | AY+BW |
      +-------+ *   +-------+ =   +-------+-------+
    n | C | D |   l | Z | W |   n | CX+DZ | CY+DW |
      +---+---+     +---+---+     +-------+-------+

    Почему работает:
    AXij = Ai1*X1j + Ai2*X2j + ... + Aik*Xj1
    BZij = Bi1*Z1j + Bi2*Z2j + ... + Bil*Zlj
    (AX + BX)ij = Ai1*X1j + Ai2*X2j + ... + Aik*Xj1 + Bi1*Z1j + Bi2*Z2j + ... + Bil*Zlj

    Матрицу можно разбивать на произвольное количество блоков,
    главное чтобы размеры блоков были согласованы для умножения.

          n           1    1          1         1      1            1
      +-------+     +----+----+-----+----+   +------+------+-----+------+
    m |   A   | *   |    |    |     |    | = | A*B1 | A*B2 | ... | A*Bk | m
      +-------+   n | B1 | B2 | ... | Bk |   +------+------+-----+------+
                    |    |    |     |    |                 k
                    +----+----+-----+----+
                              k
    ================================================================================
          1    1          1
        +----+----+-----+----+
    X = | X1 | X2 | ... | Xn | m
        +----+----+-----+----+

          1    1          1
        +----+----+-----+----+
    Y = | Y1 | Y2 | ... | Yn | p
        +----+----+-----+----+
                                   p
                  +-----------------------------------+
      X  * Y^T  = | X1*Y^T1 + X2*Y^T2 + ... + Xn*Y^Tn | m
    (m×n) (n×p)   +-----------------------------------+

    Можно делать в обе стороны: умножение матриц в сумму и сумму в умножение матриц.

    ================================================================================

    Блочные элементарные преобразования

        n   n                 	      n      n                                 n          n
      +---+---+                     +---+----------+                         +---+------------------+
    n | A | B |   row(0) *= A⁻¹   n | E | A⁻¹ * B  |  row(1) = C * row(0)  n | E |     A⁻¹ * B      |
      +-------+ =================>  +--------------+ =====================>  +----------------------+
    n | C | D |         ^         n | C |    D     |                       n | 0 | D - C * A⁻¹ * B  |
      +---+---+         | *         +---+----------+                         +---+------------------+
                        |
                   +------+---+
                   |  A⁻¹ | 0 |
                   +----------+
                   |  0   | E |
                   +------+---+


    Блочные матрицы элементарных преобразований строятся по тому же принципу, что и матрицы обычных элементарных преобразований.

    """

    P = np.array([  # (m+n)×(k+l)
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    Q = np.array([  # (k+l)×(u+v)
        [31, 32, 33],
        [34, 35, 36],
        [37, 38, 39],
        [40, 41, 42],
        [43, 44, 45],
    ])

    m = 2
    k = 3
    u = 2

    A = P[:m, :k]
    B = P[:m, k:]
    C = P[m:, :k]
    D = P[m:, k:]

    X = Q[:k, :u]
    Y = Q[:k, u:]
    Z = Q[k:, :u]
    W = Q[k:, u:]

    LT = A @ X + B @ Z
    RT = A @ Y + B @ W
    LB = C @ X + D @ Z
    RB = C @ Y + D @ W

    TOP = np.column_stack([LT, RT])
    BOTTOM = np.column_stack([LB, RB])
    RESULT = np.vstack([TOP, BOTTOM])

    print("Блочное перемножение:")
    print(RESULT)
    print()

    print("Обычное перемножение:")
    print(P @ Q)
