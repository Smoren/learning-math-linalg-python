import numpy as np

from linalg.analysers import SquareMatrixAnalyser, EchelonMatrixAnalyser
from linalg.system import LinearSystem
from linalg.transformers import LinearSystemGaussTransformer


def get_inverse_matrix(A: np.ndarray):
    """Находит обратную матрицу для квадратной матрицы"""
    # Проверяем, что матрица квадратная (2D и размерности равны)
    assert A.ndim == 2 and A.shape[0] == A.shape[1]

    # Создаем единичную матрицу того же размера, что и исходная
    # Обратная матрица A^(-1) определяется как A * A^(-1) = E,
    # где E - единичная матрица
    E = np.eye(A.shape[0], A.shape[0])

    # Создаем линейную систему: A * X = E, где X - искомая обратная матрица
    # system.A = исходная матрица, system.B = единичная матрица
    system = LinearSystem(A, E)

    # Применяем метод Гаусса для приведения матрицы A к единичной
    # Одновременно преобразуем правую часть (единичную матрицу)
    transformer = LinearSystemGaussTransformer(system)
    transformer.apply_gauss()  # После этой операции A должна стать единичной матрицей

    # Проверяем, что исходная матрица была невырожденной (обратимой)
    # Если после метода Гаусса A стала единичной матрицей - матрица обратима
    analyser = SquareMatrixAnalyser(system.A)
    if not analyser.is_identity():
        # Матрица вырожденная (определитель = 0), обратной не существует
        raise ValueError('Input matrix is singular.')

    # После преобразований system.B содержит обратную матрицу,
    # так как мы решили уравнение A * X = I и получили X = A^(-1)
    return system.B


def get_left_inverse_matrix(A: np.ndarray):
    """
    Находит левую обратную матрицу для матрицы A размера m×n, где m > n.
    Левая обратная L удовлетворяет условию: L·A = E_n
    (где E_n - единичная матрица размера n×n)

    Алгоритм:
    1. Создаем расширенную матрицу [A | I_m]
    2. Приводим левую часть (A) к ступенчатому виду методом Гаусса
    3. Если ранг A = n, то первые n строк правой части - искомая левая обратная

    Параметры:
    A: np.ndarray - исходная матрица размерности m×n, m >= n

    Возвращает:
    np.ndarray - левая обратная матрица размерности n×m

    Исключения:
    - Если m < n (невозможно найти левую обратную)
    - Если rank(A) < n (матрица не полного ранга по столбцам)
    """
    # Проверяем, что входной массив - двумерная матрица
    assert A.ndim == 2

    # Получаем размеры матрицы: m - строки, n - столбцы
    m, n = A.shape

    # Левая обратная существует только когда строк >= столбцов
    assert m >= n, "Для левой обратной требуется m >= n (больше строк, чем столбцов)"

    # Создаем единичную матрицу размера m×m (правая часть расширенной матрицы)
    Em = np.eye(m, m)

    # Создаем линейную систему с расширенной матрицей [A | I_m]
    # Идея: ищем такую матрицу E, что E·A = R (приведенная форма)
    # После преобразований первые n строк E будут левой обратной
    system = LinearSystem(A, Em)

    # Применяем метод Гаусса для приведения матрицы A к ступенчатому виду
    # При этом те же элементарные преобразования применяются и к правой части Em
    transformer = LinearSystemGaussTransformer(system)
    transformer.apply_gauss()

    # Проверяем ранг приведенной матрицы
    # Ранг должен быть равен n (полный ранг по столбцам)
    analyser = EchelonMatrixAnalyser(system.A)
    if analyser.get_rank() != n:
        raise ValueError(
            f"Невозможно найти левую обратную: ранг матрицы ({analyser.get_rank()}) "
            f"меньше числа столбцов ({n}). Матрица не имеет полного ранга по столбцам."
        )

    # После преобразований Гаусса:
    # - system.A содержит приведенную форму исходной матрицы A
    # - system.B содержит преобразованную правую часть (изначально I_m)
    #
    # Из теории: если E - матрица элементарных операций такая, что E·A = R,
    # где R - приведенная форма, то первые n строк E дают левую обратную L,
    # при условии, что ранг A = n и R = [I_n; 0] (первые n строк - единичная матрица)
    return system.B[:n]  # Берем первые n строк преобразованной правой части


def get_right_inverse_matrix(A: np.ndarray):
    """
    Прямой метод нахождения правой обратной (без явного транспонирования)

    Алгоритм:
    1. Создаем расширенную матрицу [A^T | E_n]
    2. Применяем метод Гаусса для приведения A^T к виду [E_m; 0]
    3. Берем первые m столбцов преобразованной правой части

    Этот метод эквивалентен предыдущему, но более явно показывает связь
    """
    assert A.ndim == 2
    m, n = A.shape

    if m > n:
        raise ValueError("Для правой обратной требуется m <= n")

    # Работаем с транспонированной матрицей A^T
    A_T = A.T

    # Создаем расширенную матрицу [A^T | I_n]
    En = np.eye(n)
    system = LinearSystem(A_T, En)

    # Применяем метод Гаусса
    transformer = LinearSystemGaussTransformer(system)
    transformer.apply_gauss()

    # Проверяем ранг A^T (должен быть m)
    analyser_T = EchelonMatrixAnalyser(system.A)
    if analyser_T.get_rank() != m:
        raise ValueError("Транспонированная матрица не имеет полного ранга")

    # После приведения A^T к виду [I_m; 0] (n×m матрица)
    # Правая часть En преобразуется в некоторую матрицу P (n×n)
    # Первые m строк P (размер m×n) - это левая обратная к A^T
    # Тогда правая обратная к A = (первые m строк P)^T

    L_Atransposed = system.B[:m]  # m×n матрица
    R = L_Atransposed.T  # n×m матрица - правая обратная к A

    return R
