import numpy as np

"""
Замечание про обратные матрицы:
(AB)^-1 = B^-1 * A^-1

Доказательство: Попробуем предъявить обратную матрицу к матрице AB.

(A * B) * (B^-1 * A^-1) = A * (B * B^-1) * A^-1 = A * E * A^-1 = A * A^-1 = E.
Значит, обратная матрица к AB - это B^-1 * A^-1.

С другой стороны тоже работает:
(B^-1 * A^-1) * (A * B) = B^-1 * (A^-1 * A) * B = B^-1 * E * B = B^-1 * B = E.

======================

ТЕОРЕМА
Если A - квадратная матрица, то следующие утверждения эквивалентны друг другу:
1. A * x = 0 имеет единственное решение: x = 0 (x ∈ R^n)
2. A^T * y = 0 имеет единственное решение: y = 0 (y ∈ R^n)
3. A = U1 * U2 * ... * Uk, где U1, U2, ..., Uk, где Ui - элементарные матрицы (соответствующие элементарным преобразованиям: add, mul, swap)
4. Существует обратная матрица A^-1
5. Матрица A обратима слева (∃ L: LA = E)
6. Матрица A обратима справа (∃ R: AR = E)
"""

"""
Если A, B ∈ Mmn(R) (являются матрицами m×n),
E_A = {x | Ax = 0}, E_B = {x | Ay = 0} (множества решений),
то следующие утверждения эквивалентны друг другу:
1. E_A = E_B
2. A можно привести к B с помощью элементарных преобразований
3. A = C * B, где C ∈ Mmm(R) и является обратимой матрицей (C = U1 * U2 * ... * Uk, где Ui - элементарные матрицы)
4. Улучшенный ступенчатый вид матриц A и B совпадает
"""


def example_transform_matrix_add_row():
    A = np.array([
        [1,  2,  3,  4,  5],
        [6,  7,  8,  9,  10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 1, 0],  # i = 1, j = 3
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1],
    ])

    print(A)
    print(T @ A)  # к строке с индексом i=1 прибавляем строку с индексом j=3
    print(A @ T)  # к столбцу с индексом j=3 прибавляем столбец с индексом i=1

    Ti = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, -1, 0],  # i = 1, j = 3
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1],
    ])

    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_transform_matrix_mul_row():
    A = np.array([
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 2, 0],  # i = 3, множитель = 2
        [0, 0, 0, 0, 1],
    ])

    print(A)
    print(T @ A)  # умножаем строку с индексом 3 на 2
    print(A @ T)  # умножаем строку с индексом 3 на 2

    Ti = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1/2, 0],  # i = 3, множитель = 1/2
        [0, 0, 0, 0, 1],
    ])
    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_transform_matrix_swap_rows():
    A = np.array([
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1],  # i = 1, j = 4
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0],  # i = 4, j = 1
    ])

    print(A)
    print(T @ A)  # меняем местами строки с индексами 1 и 4
    print(A @ T)  # меняем местами столбцы с индексами 1 и 4

    Ti = T
    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)
