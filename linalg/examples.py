import numpy as np

"""
Замечание про обратные матрицы:
(AB)^-1 = B^-1 * A^-1

Доказательство: Попробуем предъявить обратную матрицу к матрице AB.

(A * B) * (B^-1 * A^-1) = A * (B * B^-1) * A^-1 = A * E * A^-1 = A * A^-1 = E.
Значит, обратная матрица к AB - это B^-1 * A^-1.

С другой стороны тоже работает:
(B^-1 * A^-1) * (A * B) = B^-1 * (A^-1 * A) * B = B^-1 * E * B = B^-1 * B = E.

======================

ТЕОРЕМА
Если A - квадратная матрица, то следующие утверждения эквивалентны друг другу:
1. A * x = 0 имеет единственное решение: x = 0 (x ∈ R^n)
2. A^T * y = 0 имеет единственное решение: y = 0 (y ∈ R^n)
3. A = U1 * U2 * ... * Uk, где U1, U2, ..., Uk, где Ui - элементарные матрицы (соответствующие элементарным преобразованиям: add, mul, swap)
4. Существует обратная матрица A^-1
5. Матрица A обратима слева (∃ L: LA = E)
6. Матрица A обратима справа (∃ R: AR = E)
"""

"""
Если A, B ∈ Mmn(R) (являются матрицами m×n),
E_A = {x | Ax = 0}, E_B = {x | Ay = 0} (множества решений),
то следующие утверждения эквивалентны друг другу:
1. E_A = E_B
2. A можно привести к B с помощью элементарных преобразований
3. Существует C: A = C * B, где C ∈ Mmm(R) и C является обратимой матрицей (C = U1 * U2 * ... * Uk, где Ui - элементарные матрицы)
4. Улучшенный ступенчатый вид матриц A и B совпадает (для любой матрицы ступенчатый вид единственный)
"""


def example_transform_matrix_add_row():
    A = np.array([
        [1,  2,  3,  4,  5],
        [6,  7,  8,  9,  10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 1, 0],  # i = 1, j = 3
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1],
    ])

    print(A)
    print(T @ A)  # к строке с индексом i=1 прибавляем строку с индексом j=3
    print(A @ T)  # к столбцу с индексом j=3 прибавляем столбец с индексом i=1

    Ti = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, -1, 0],  # i = 1, j = 3
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1],
    ])

    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_transform_matrix_mul_row():
    A = np.array([
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 2, 0],  # i = 3, множитель = 2
        [0, 0, 0, 0, 1],
    ])

    print(A)
    print(T @ A)  # умножаем строку с индексом 3 на 2
    print(A @ T)  # умножаем строку с индексом 3 на 2

    Ti = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1/2, 0],  # i = 3, множитель = 1/2
        [0, 0, 0, 0, 1],
    ])
    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_transform_matrix_swap_rows():
    A = np.array([
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    T = np.array([
        [1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1],  # i = 1, j = 4
        [0, 0, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0],  # i = 4, j = 1
    ])

    print(A)
    print(T @ A)  # меняем местами строки с индексами 1 и 4
    print(A @ T)  # меняем местами столбцы с индексами 1 и 4

    Ti = T
    print(Ti @ T)  # Обратная матрица к T (можно использовать для обратного преобразования)


def example_multiply_per_block():
    """
    Блочные формулы

        k   l         u   v           u       v
      +---+---+     +---+---+     +-------+-------+
    m | A | B |   k | X | Y |   m | AX+BZ | AY+BW |
      +-------+ *   +-------+ =   +-------+-------+
    n | C | D |   l | Z | W |   n | CX+DZ | CY+DW |
      +---+---+     +---+---+     +-------+-------+
    """

    P = np.array([  # (m+n)×(k+l)
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
        [21, 22, 23, 24, 25],
    ])
    Q = np.array([  # (k+l)×(u+v)
        [31, 32, 33],
        [34, 35, 36],
        [37, 38, 39],
        [40, 41, 42],
        [43, 44, 45],
    ])

    m = 2
    k = 3
    u = 2

    A = P[:m, :k]
    B = P[:m, k:]
    C = P[m:, :k]
    D = P[m:, k:]

    X = Q[:k, :u]
    Y = Q[:k, u:]
    Z = Q[k:, :u]
    W = Q[k:, u:]

    LT = A @ X + B @ Z
    RT = A @ Y + B @ W
    LB = C @ X + D @ Z
    RB = C @ Y + D @ W

    TOP = np.column_stack([LT, RT])
    BOTTOM = np.column_stack([LB, RB])
    RESULT = np.vstack([TOP, BOTTOM])

    print("Блочное перемножение:")
    print(RESULT)
    print()

    print("Обычное перемножение:")
    print(P @ Q)
